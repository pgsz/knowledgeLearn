# 算法复杂度



##  迭代与递归

### 迭代

重复执行某个任务的控制结构

- for
- while
- 嵌套循环



### 递归

通过函数调用自身来解决问题；包含两阶段：

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到 ”终止条件“。
2. **归**：触发 “终止条件” 后，查询从最深层的递归函数开始逐层返回，汇聚每一层的结果。

三个要素：

1. 终止条件：用于决定什么时候由 “递” 转 “归”
2. 递归调用：对应 ”递“ ，函数调用自身，通常输出更小或更简化的参数
3. 返回结果：对应 “归”， 将当前递归层级的结果返回至上一层

#### 调用栈

 递归函数每次调用自身，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。导致： 

1. 递归通常比迭代更加耗费内存空间
2. 递归通常比循环的时间效率更低

#### 尾递归

函数在返回前的最后一步才进行递归回调；可被编译器或解释器优化

#### 递归数

 斐波那契数列 : 0,1,1,2,3,5,8,13...

```js
/* 斐波那契数列：递归 */
function fib(n) {
    // 终止条件 f(1) = 0, f(2) = 1
    if (n === 1 || n === 2) return n - 1;
    // 递归调用 f(n) = f(n-1) + f(n-2)
    const res = fib(n - 1) + fib(n - 2);
    // 返回结果 f(n)
    return res;
}
```



### 两者对比

|          |                  迭代                  |                             递归                             |
| :------: | :------------------------------------: | :----------------------------------------------------------: |
| 实现方式 |                循环结构                |                         函数调用自身                         |
| 时间效率 |      效率通常较高，无函数调用开销      |                   每次函数调用都会产生开销                   |
| 内存使用 |       通常使用固定大小的内存空间       |              累计函数调用可能使用大量的栈帧空间              |
| 使用问题 | 使用与简单循环任务，代码直观、可读性好 | 使用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |





