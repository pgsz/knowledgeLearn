# 搜索



## 二分查找

二分查找：基于分治策略的高效搜索算法。利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。

时间复杂度： O(log n)

空间复杂度： O(1)

一般采用 **双闭区间**写法，不容易出错。

|              |       双闭区间       |     左闭右开     |
| :----------: | :------------------: | :--------------: |
|   搜索区间   |       [ i, j ]       |     [ i, j )     |
|  初始化指针  |   i = 0, j = n - 1   |   i = 0, j = n   |
| 循环终止条件 |        i > j         |      i >= j      |
| 缩小区间操作 | i = m + 1, j = m - 1 | i = m + 1, j = m |



### 优点与局限性

优点：时间和空间 较好的性能

- 时间效率高：在大数据量下，对数阶的时间复杂度具有显著优势。
- 无需额外空间：更节省空间。

缺点：

- 仅适用于 有序数据。
- 仅使用于 数组。不适用于 链表 或 基于链表实现的数据结构。
- 小数据量下，线性查找性能更加。线性查找中，每轮只需 1 次判断操作；二分查找中，需要 1 次加分、1 次除法、1 ~ 3 次的判断操作、1 次加法（减法），共 4 ~ 6 个单元操作。



## 二分查找插入点

给定一个长度为 n 的有序数组 nums 和一个元素 target，现将 taget 插入数组 nums 中，并保持其有序性。若数组存在元素 taget，则插入到其左方。返回插入后 target 在数组中的索引。



### 无重复元素

数组不存在 重复 元素。

```js
/* 二分查找插入点（无重复元素） */
function binarySearchInsertionSimple (nums, target) {
  let i = 0
  let j = nums.length - 1 // 初始化双闭区间 [0, n-1]
  while (i <= j) {
    const m = Math.floor((i + j) / 2) // 计算中点索引 m, 使用 Math.floor() 向下取整
    if (nums[m] < target) {
      i = m + 1 // target 在区间 [m+1, j] 中
    } else if (nums[m] > target) {
      j = m - 1 // target 在区间 [i, m-1] 中
    } else {
      return m // 找到 target ，返回插入点 m
    }
  }
  // 未找到 target ，返回插入点 i
  return i
}
```



### 存在重复元素

数组可能存在 重复元素







