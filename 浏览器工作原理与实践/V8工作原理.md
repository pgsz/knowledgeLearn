# V8工作原理



### js 语言类型

- 静态语言：使用之前就需要确认其变量数据类型

- 动态语言：在运行过程中需要检测数据类型的语言

  

- 弱类型语言：支持隐式转换的语言
- 强类型语言：不支持隐式转换的语言



js 是 动态的弱类型语言

<img src=".\images\语言类型图.webp" style="zoom: 50%;" />



### 栈和堆



- 原始类型数据的数据值保存在 - 栈：Number、String、Boolean、Undefined、Null、BigInt、Symbol
- 引用类型的值存放在 - 堆：Object



- 原始类型数据赋值会完整赋值变量值
- 引用类型的赋值会复制引用地址



问题：所有数据直接存放在 栈 中可以嘛？

回答：不可以。因为 js 引擎需要用栈来维护程序执行期间上下文状态；如果栈空间大了，所有数据存放在栈空间里面，会影响到上下文切换的效率，进而影响到整个程序的执行效率。



### 垃圾回收

#### 栈

ESP：记录当前执行状态的指针

js 引擎通过向下移动 ESP 来销毁该函数确保存放在栈中的执行上下文



#### 堆

代际假说：

1. 大部分对象在内存中存在的时间很短；简单说：很多对象一经分配内存，很快就变得不可访问
2. 不死对象，会活的更久



堆分为：

- 新生代：存放生存时间短的对象；通常支持 1~8M 的容量
- 老生代：存放生存时间久的对象



V8：

- 副垃圾回收器：负责新生代的垃圾回收
- 主垃圾回收器：负责老生代的垃圾回收



垃圾回收器流程：

1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理



副垃圾回收器 - 新生代

Scavenge算法：对象区域和空闲区域；对象放入对象区域，当快要写满时，执行垃圾清理操作（标记、回收、整理：复制到空闲区域，有序排列）；完成复制后，对象区域和空闲区域进行角色翻转。

对象晋升策略：经过两次垃圾回收依然存活的话，会被移入到老生区中。



主垃圾回收器 - 老生代

来源：新生区晋升的对象、一些大的对象直接被分配到老生区

特点：对象占用空间大、对象存活时间长

 标记 - 清除 - 整理：

1. 遍历堆中所有对象，做标记
2. 对于代码环境中 使用的变量 和 被强引用 的变量取消标记
3. 把 依然被标记的对象 当成垃圾清理
4. 整理：存活对象往一边靠拢

增量标记算法：

分为一个个子标记过程，把一个完整的垃圾回收任务拆分为很多小人物，让垃圾回收和js应用逻辑交替进行，确保不影响页面流畅性。



### 编译器和解释器

机器无法直接理解代码；按语言的执行流程

- 编译型语言：程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序可以直接运行该二进制文件，无需再次重新编译。
- 解释性语言：每次运行时都需要通过解释器对程序进行动态解释和执行。

<img src=".\images\编译器和解释器“翻译”代码.webp" style="zoom:50%;" />



### V8 如何执行 js 代码

1. 生成抽象语法树（AST）和执行上下文
   1. AST 两个过程： 分词（词法分析）；解析（语法分析）
2. 生成字节码：字节码是介于 AST 和机器码之间的一种代码；字节码需要解释器将其转换为机器码后才能执行。（使用字节码减少系统的内存使用）
3. 执行代码：解释器执行（解释器生成、执行字节码）；编译器将热点代码（重复执行多次的代码）编译为机器码。

<img src=".\images\即时编译（JIT）技术.webp" style="zoom:50%;" />