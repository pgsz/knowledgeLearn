# 前端序列帧

前提：序列帧图片：`250` 张；在 `images `下名称为：  `spzp__00000` -  `spzp__00249`  的 `png` 图片



## 雪碧图

不阐述



## scss + animation

方式简单，但无法判断图片是否加载完成；无法精细化控制。

```scss
// 定义变量：总帧数
$total-frames: 249;
$step: 100 / ($total-frames + 1);

@keyframes animation_sequence_frame {
  @for $i from 0 through $total-frames {
    $percentage: ($i * $step) * 1%;
    $imageIndex: if($i < 10, '00#{$i}', if($i < 100, '0#{$i}', '#{$i}'));

    #{$percentage} {
      background: url('./images/spzp__00#{$imageIndex}.png') no-repeat center center / 100% 100%;
    }
  }
}	


animation: animation_sequence_frame 5s linear infinite; 
```



## image + setTimeout + 预加载

**不推荐 setTimeout ** 

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      #animation-container {
        width: 200px;
        height: 244px;
        background: #f0f0f0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #loading-text {
        color: #666;
        font-family: Arial;
      }

      #animation-img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        /* 初始隐藏 */
        display: none;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="animation-container">
      <div id="loading-text">加载中... <span id="progress">0%</span></div>
      <img id="animation-img" alt="动画帧" />
    </div>

    <script>
      class OptimizedSpriteAnimation {
        constructor(containerId, frameCount, fps = 60) {
          this.container = document.getElementById(containerId);
          this.img = document.getElementById("animation-img");
          this.loadingText = document.getElementById("loading-text");
          this.progressSpan = document.getElementById("progress");

          this.frameCount = frameCount;
          this.currentFrame = 0;
          this.fps = fps;
          this.isPlaying = false;
          this.animationId = null;
          this.loadedFrames = 0;
          this.frames = new Array(frameCount);
          this.isPreloaded = false;

          this.startPreload();
        }

        getFramePath(frameNumber) {
          return `./images/spzp__${frameNumber.toString().padStart(5, "0")}.png`;
        }

        startPreload() {
          console.log("开始预加载图片...");

          for (let i = 0; i < this.frameCount; i++) {
            const img = new Image();
            img.onload = () => {
              this.loadedFrames++;
              const progress = Math.round((this.loadedFrames / this.frameCount) * 100);
              this.progressSpan.textContent = `${progress}%`;

              // 存储加载完成的图片对象
              this.frames[i] = img;

              if (this.loadedFrames === this.frameCount) {
                this.onPreloadComplete();
              }
            };

            img.onerror = () => {
              console.error(`图片加载失败: frame_${i.toString().padStart(5, "0")}.png`);
              this.loadedFrames++;
              if (this.loadedFrames === this.frameCount) {
                this.onPreloadComplete();
              }
            };

            img.src = this.getFramePath(i);
          }
        }

        onPreloadComplete() {
          console.log("所有图片预加载完成");
          this.isPreloaded = true;

          // 隐藏加载提示，显示动画
          this.loadingText.classList.add("hidden");
          this.img.style.display = "block";

          // 开始播放动画
          this.play();
        }

        updateFrame() {
          if (this.frames[this.currentFrame]) {
            this.img.src = this.frames[this.currentFrame].src;
          }
          this.currentFrame = (this.currentFrame + 1) % this.frameCount;
        }

        play() {
          if (this.isPlaying || !this.isPreloaded) return;

          this.isPlaying = true;
          const interval = 1000 / this.fps;

          const animate = () => {
            this.updateFrame();
            if (this.isPlaying) {
              this.animationId = setTimeout(animate, interval);
            }
          };

          animate();
        }

        pause() {
          this.isPlaying = false;
          if (this.animationId) {
            clearTimeout(this.animationId);
          }
        }
      }

      // 使用示例
      const animation = new OptimizedSpriteAnimation("animation-container", 250);
    </script>
  </body>
</html>
```



## image + requestAnimationFrame + 分批懒加载方案

**推荐**  分批懒加载 可根据实际情况是否需要

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      #animation-container {
        width: 200px;
        height: 244px;
        background: #f0f0f0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #animation-img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
    </style>
  </head>
  <body>
    <div id="animation-container">
      <img id="animation-img" alt="动画帧" />
    </div>

    <script>
      class ProgressiveSpriteAnimation {
        constructor(containerId, frameCount, fps = 60, batchSize = 50) {
          this.container = document.getElementById(containerId);
          this.img = this.container.querySelector("img");
          this.frameCount = frameCount;
          this.currentFrame = 0;
          this.fps = fps;
          this.batchSize = batchSize;
          this.frames = new Array(frameCount);
          this.loadedBatches = new Set();
          this.isPlaying = false;

          this.startProgressiveLoad();
        }

        startProgressiveLoad() {
          // 首先加载前几帧（确保动画可以立即开始）
          this.loadBatch(0, 10);

          // 然后分批加载剩余帧
          for (let i = 10; i < this.frameCount; i += this.batchSize) {
            setTimeout(() => {
              this.loadBatch(i, Math.min(i + this.batchSize, this.frameCount));
            }, i * 10); //  staggered loading
          }
        }

        loadBatch(start, end) {
          for (let i = start; i < end; i++) {
            const img = new Image();
            img.onload = () => {
              this.frames[i] = img;
              this.loadedBatches.add(Math.floor(i / this.batchSize));

              // 如果当前帧已加载，可以开始播放
              if (i === 0 && !this.isPlaying) {
                this.play();
              }
            };
            img.src = this.getFramePath(i);
          }
        }

        getFramePath(frameNumber) {
          return `./images/spzp__${frameNumber.toString().padStart(5, "0")}.png`;
        }

        updateFrame() {
          if (this.frames[this.currentFrame]) {
            // 帧已加载，直接显示
            this.img.src = this.frames[this.currentFrame].src;
          } else {
            // 帧未加载，显示加载中的占位图或保持上一帧
            console.log(`帧 ${this.currentFrame} 尚未加载`);
          }

          this.currentFrame = (this.currentFrame + 1) % this.frameCount;
        }

        play() {
          if (this.isPlaying) return;

          this.isPlaying = true;
          // 根据fps控制帧率
          let then = performance.now();
          const interval = 1000 / this.fps;

          const animateWithFPS = (now) => {
            requestAnimationFrame(animateWithFPS);
            const delta = now - then;

            if (delta > interval) {
              // 补偿时间误差，保持帧率稳定
              then = now - (delta % interval);
              this.updateFrame();
            }
          };

          requestAnimationFrame(animateWithFPS);
        }
      }

      new ProgressiveSpriteAnimation("animation-container", 250);
    </script>
  </body>
</html>
```



## canvas + requestAnimationFrame + 预加载

**推荐：性能更好**

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        background-color: #000;
      }
      canvas {
        border: 1px solid #ccc;
        background-color: transparent;
      }
    </style>
  </head>
  <body>
    <canvas id="animationCanvas" width="200" height="244"></canvas>

    <script>
      class CanvasAnimation {
        constructor(canvasId, frameCount, fps = 24) {
          this.canvas = document.getElementById(canvasId);
          // 确保 canvas 支持透明度
          this.ctx = this.canvas.getContext("2d", { alpha: true });
          this.frameCount = frameCount;
          this.currentFrame = 0;
          this.fps = fps;
          this.isPlaying = false;
          this.animationId = null;
          this.frames = new Array(frameCount);
          this.loadedCount = 0;

          this.preloadFrames();
        }

        preloadFrames() {
          for (let i = 0; i < this.frameCount; i++) {
            const img = new Image();
            img.onload = () => {
              this.loadedCount++;
              this.frames[i] = img;
              if (this.loadedCount === this.frameCount) {
                console.log("所有图片加载完成");
                this.play();
              }
            };
            img.onerror = () => {
              console.error(`图片加载失败: frame_${i.toString().padStart(5, "0")}.png`);
              this.loadedCount++;
              if (this.loadedCount === this.frameCount) {
                this.play();
              }
            };

            img.src = this.getFramePath(i);
          }
        }

        getFramePath(frameNumber) {
          return `./images/spzp__${frameNumber.toString().padStart(5, "0")}.png`;
        }

        drawFrame() {
          if (this.frames[this.currentFrame]) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.frames[this.currentFrame], 0, 0, this.canvas.width, this.canvas.height);
          } else {
            console.log(`帧 ${this.currentFrame} 尚未加载`);
          }
          this.currentFrame = (this.currentFrame + 1) % this.frameCount;
        }

        play() {
          if (this.isPlaying) return;

          this.isPlaying = true;
          const interval = 1000 / this.fps;

          //   定时器
          //   const animate = () => {
          //     this.drawFrame();

          //     if (this.isPlaying) {
          //       this.animationId = setTimeout(animate, interval);
          //     }
          //   };

          //   animate();

          //   requestAnimationFrame
          let then = performance.now();
          const animateWithFPS = (now) => {
            requestAnimationFrame(animateWithFPS);
            const delta = now - then;
            if (delta > interval) {
              // 补偿时间误差，保持帧率文档
              then = now - (delta % interval);
              this.drawFrame();
            }
          };

          requestAnimationFrame(animateWithFPS);
        }

        pause() {
          this.isPlaying = false;
          if (this.animationId) {
            clearTimeout(this.animationId);
          }
        }
      }

      // 使用示例
      const canvasAnim = new CanvasAnimation("animationCanvas", 250, 30);
    </script>
  </body>
</html>
```



## canvas 完整 demo

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas序列帧动画</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #1a1a1a;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
      }

      .container {
        text-align: center;
        max-width: 800px;
      }

      .canvas-container {
        position: relative;
        margin: 20px 0;
        border: 2px solid #333;
        border-radius: 8px;
        overflow: hidden;
      }

      #animationCanvas {
        background: #000;
        display: block;
      }

      .controls {
        margin: 20px 0;
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      button {
        padding: 10px 20px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }

      button:hover {
        background: #45a049;
      }

      button:disabled {
        background: #666;
        cursor: not-allowed;
      }

      .loading-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      .progress-bar {
        width: 80%;
        height: 20px;
        background: #333;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: #4caf50;
        width: 0%;
        transition: width 0.3s;
      }

      .stats {
        margin-top: 10px;
        font-size: 14px;
        color: #ccc;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Canvas序列帧动画演示</h1>

      <div class="canvas-container">
        <canvas id="animationCanvas" width="800" height="450"></canvas>

        <div id="loadingScreen" class="loading-screen">
          <div>加载序列帧中...</div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          <div id="progressText">0%</div>
        </div>
      </div>

      <div class="controls">
        <button id="playBtn" disabled>播放</button>
        <button id="pauseBtn" disabled>暂停</button>
        <button id="stopBtn" disabled>停止</button>
        <button id="restartBtn" disabled>重新开始</button>

        <select id="fpsSelect">
          <option value="15">15 FPS</option>
          <option value="24" selected>24 FPS</option>
          <option value="30">30 FPS</option>
          <option value="60">60 FPS</option>
        </select>
      </div>

      <div class="stats">
        <div>当前帧: <span id="currentFrame">0</span> / <span id="totalFrames">0</span></div>
        <div>FPS: <span id="fpsDisplay">0</span></div>
        <div>状态: <span id="status">加载中...</span></div>
      </div>
    </div>

    <script>
      class CanvasSpriteAnimation {
        constructor(canvasId, options = {}) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");

          // 配置选项
          this.options = {
            frameCount: options.frameCount || 250,
            basePath: options.basePath || "frames/",
            fileNamePattern: options.fileNamePattern || "frame_{index}.png",
            defaultFPS: options.defaultFPS || 24,
            batchSize: options.batchSize || 25,
            ...options,
          };

          // 动画状态
          this.frames = [];
          this.loadedFrames = 0;
          this.currentFrame = 0;
          this.isPlaying = false;
          this.isPreloaded = false;
          this.hasAutoPlayed = false;

          // 帧率控制
          this.fps = this.options.defaultFPS;
          this.interval = 1000 / this.fps;
          this.then = 0;
          this.animationId = null;

          // 性能监控
          this.frameCount = 0;
          this.lastFpsUpdate = 0;
          this.currentFps = 0;

          // DOM元素引用
          this.elements = {
            playBtn: document.getElementById("playBtn"),
            pauseBtn: document.getElementById("pauseBtn"),
            stopBtn: document.getElementById("stopBtn"),
            restartBtn: document.getElementById("restartBtn"),
            loadingScreen: document.getElementById("loadingScreen"),
            progressFill: document.getElementById("progressFill"),
            progressText: document.getElementById("progressText"),
            currentFrame: document.getElementById("currentFrame"),
            totalFrames: document.getElementById("totalFrames"),
            fpsDisplay: document.getElementById("fpsDisplay"),
            status: document.getElementById("status"),
            fpsSelect: document.getElementById("fpsSelect"),
          };

          this.elements.totalFrames.textContent = this.options.frameCount;

          this.initEventListeners();
          this.startPreload();
        }

        initEventListeners() {
          // 控制按钮事件
          this.elements.playBtn.addEventListener("click", () => this.play());
          this.elements.pauseBtn.addEventListener("click", () => this.pause());
          this.elements.stopBtn.addEventListener("click", () => this.stop());
          this.elements.restartBtn.addEventListener("click", () => this.restart());

          // FPS选择事件
          this.elements.fpsSelect.addEventListener("change", (e) => {
            this.setFPS(parseInt(e.target.value));
          });
        }

        getFramePath(frameIndex) {
          const index = frameIndex.toString().padStart(5, "0");
          return this.options.basePath + this.options.fileNamePattern.replace("{index}", index);
        }

        startPreload() {
          console.log("开始预加载序列帧...");
          this.elements.status.textContent = "预加载中...";

          // 先加载前几帧确保快速启动
          this.loadBatch(0, Math.min(10, this.options.frameCount));

          // 分批加载剩余帧
          for (let i = 10; i < this.options.frameCount; i += this.options.batchSize) {
            setTimeout(() => {
              this.loadBatch(i, Math.min(i + this.options.batchSize, this.options.frameCount));
            }, i * 5); // 错开加载时间
          }
        }

        async loadBatch(start, end) {
          const promises = [];

          for (let i = start; i < end; i++) {
            promises.push(this.loadFrame(i));
          }

          await Promise.allSettled(promises);

          // 检查是否所有帧都加载完成
          if (this.loadedFrames === this.options.frameCount) {
            this.onPreloadComplete();
          }
        }

        loadFrame(index) {
          return new Promise((resolve, reject) => {
            const img = new Image();

            img.onload = () => {
              this.frames[index] = img;
              this.loadedFrames++;
              this.updateProgress();

              this.checkAutoPlay();

              resolve(img);
            };

            img.onerror = () => {
              console.error(`帧 ${index + 1} 加载失败`);
              this.loadedFrames++;
              this.updateProgress();
              this.checkAutoPlay();
              reject(new Error(`加载帧 ${index + 1} 失败`));
            };

            img.src = this.getFramePath(index);
          });
        }

        updateProgress() {
          const progress = (this.loadedFrames / this.options.frameCount) * 100;
          this.elements.progressFill.style.width = `${progress}%`;
          this.elements.progressText.textContent = `${Math.round(progress)}%`;
        }

        checkAutoPlay() {
          // 方案1：快速启动（加载10帧后开始）
          const minFramesToStart = Math.min(10, this.options.frameCount);
          if (!this.isPreloaded && this.loadedFrames >= minFramesToStart && !this.hasAutoPlayed) {
            this.hasAutoPlayed = true;
            this.isPreloaded = true;
            this.enableControls();
            this.play();

            console.log(`自动播放：已加载 ${this.loadedFrames}/${this.options.frameCount} 帧`);
          }

          // 方案2：完整加载检查（备用）
          //   if (this.loadedFrames === this.options.frameCount && !this.hasAutoPlayed) {
          //     this.hasAutoPlayed = true;
          //     this.onPreloadComplete();
          //     this.play();

          //     console.log("自动播放：所有帧加载完成");
          //   }
        }

        onPreloadComplete() {
          console.log("所有序列帧加载完成");
          this.isPreloaded = true;
          this.elements.loadingScreen.classList.add("hidden");
          this.elements.status.textContent = "准备就绪";
          this.enableControls();
        }

        enableControls() {
          this.elements.playBtn.disabled = false;
          this.elements.pauseBtn.disabled = false;
          this.elements.stopBtn.disabled = false;
          this.elements.restartBtn.disabled = false;
        }

        setFPS(fps) {
          this.fps = fps;
          this.interval = 1000 / this.fps;
          this.elements.status.textContent = `FPS设置为: ${fps}`;
        }

        play() {
          if (this.isPlaying || !this.isPreloaded) return;

          this.isPlaying = true;
          this.then = performance.now();
          this.lastFpsUpdate = this.then;
          this.animationId = requestAnimationFrame(this.animate.bind(this));

          this.elements.status.textContent = "播放中";
          console.log("开始播放动画");
        }

        animate(now) {
          if (!this.isPlaying) return;

          this.animationId = requestAnimationFrame(this.animate.bind(this));

          // 帧率控制
          const delta = now - this.then;

          if (delta > this.interval) {
            // 误差补偿，保持帧率稳定
            this.then = now - (delta % this.interval);

            this.updateFrame();
            this.updateFPS(now);
          }
        }

        updateFrame() {
          // 清除画布
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 绘制当前帧
          if (this.frames[this.currentFrame]) {
            const img = this.frames[this.currentFrame];

            // 居中绘制，保持宽高比
            // const scale = Math.min(this.canvas.width / img.width, this.canvas.height / img.height);

            // const width = img.width * scale;
            // const height = img.height * scale;
            const width = img.width;
            const height = img.height;
            const x = (this.canvas.width - width) / 2;
            const y = (this.canvas.height - height) / 2;

            this.ctx.drawImage(img, x, y, width, height);

            // 绘制帧信息
            this.drawFrameInfo();
          }

          // 更新帧计数
          this.currentFrame = (this.currentFrame + 1) % this.options.frameCount;
          this.elements.currentFrame.textContent = this.currentFrame + 1;
          this.frameCount++;
        }

        drawFrameInfo() {
          // 在画布上绘制调试信息
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          this.ctx.fillRect(10, 10, 200, 60);

          this.ctx.fillStyle = "white";
          this.ctx.font = "14px Arial";
          this.ctx.fillText(`帧: ${this.currentFrame + 1}/${this.options.frameCount}`, 20, 30);
          this.ctx.fillText(`FPS: ${this.currentFps}`, 20, 50);
          this.ctx.fillText(`状态: ${this.isPlaying ? "播放中" : "暂停"}`, 20, 70);
        }

        updateFPS(now) {
          // 每秒更新一次FPS显示
          if (now - this.lastFpsUpdate >= 1000) {
            this.currentFps = this.frameCount;
            this.elements.fpsDisplay.textContent = this.currentFps;
            this.frameCount = 0;
            this.lastFpsUpdate = now;
          }
        }

        pause() {
          if (!this.isPlaying) return;

          this.isPlaying = false;
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }

          this.elements.status.textContent = "已暂停";
          console.log("动画暂停");
        }

        stop() {
          this.pause();
          this.currentFrame = 0;
          this.elements.currentFrame.textContent = "0";
          this.clearCanvas();

          this.elements.status.textContent = "已停止";
          console.log("动画停止");
        }

        restart() {
          this.stop();
          setTimeout(() => this.play(), 100);
        }

        clearCanvas() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 绘制重启提示
          this.ctx.fillStyle = "white";
          this.ctx.font = "24px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText("点击播放开始动画", this.canvas.width / 2, this.canvas.height / 2);
          this.ctx.textAlign = "left";
        }

        // 销毁方法，清理资源
        destroy() {
          this.pause();
          this.frames = [];
          this.loadedFrames = 0;
          this.isPreloaded = false;
        }
      }

      // 页面加载完成后初始化动画
      document.addEventListener("DOMContentLoaded", () => {
        // 初始化动画实例
        const animation = new CanvasSpriteAnimation("animationCanvas", {
          frameCount: 250, // 总帧数
          basePath: "./images/", // 帧图片路径
          fileNamePattern: "spzp__{index}.png", // 文件名模式
          defaultFPS: 24, // 默认帧率
          batchSize: 25, // 分批加载大小
        });

        // 暴露到全局便于调试
        window.animation = animation;

        // 添加键盘控制
        document.addEventListener("keydown", (e) => {
          console.log(e.code);
          switch (e.code) {
            case "Space":
              e.preventDefault();
              if (animation.isPlaying) {
                animation.pause();
              } else {
                animation.play();
              }
              break;
            case "ArrowRight":
              animation.setFPS(Math.min(animation.fps + 5, 60));
              break;
            case "ArrowLeft":
              animation.setFPS(Math.max(animation.fps - 5, 5));
              break;
            case "KeyR":
              animation.restart();
              break;
          }
        });

        console.log("动画初始化完成，使用空格键播放/暂停，左右箭头调整FPS，R键重新开始");
      });

      // 兼容性处理
      window.requestAnimationFrame =
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };

      window.cancelAnimationFrame =
        window.cancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        function (id) {
          window.clearTimeout(id);
        };
    </script>
  </body>
</html>
```



## 知识点

#### requestAnimationFrame   动画API



#### performance.now()   

高精度时间戳

|   特性   |     performance.now()      |       Date.now()        |
| :------: | :------------------------: | :---------------------: |
|   精度   |  微秒级（最高可达5微秒）   |         毫秒级          |
|  单调性  | 始终递增，不受系统时间影响 |   受系统时间调整影响    |
|  返回值  |   浮点数（高精度时间戳）   |   整数（Unix时间戳）    |
| 时间起点 |        页面加载开始        | 1970-01-01 00:00:00 UTC |
| 适用场景 |     性能测量、动画计时     |      日期时间操作       |

下面代码： 精确控制动画帧率、自动误差补偿、性能优化等

不做处理也可以运行，以屏幕刷新率运行；但可能造成 性能浪费 和 帧率不稳定。

```js
// 根据fps控制帧率
let then = performance.now();          // 记录起始时间
const interval = 1000 / this.fps;      // 计算每帧的时间间隔

const animateWithFPS = (now) => {
  requestAnimationFrame(animateWithFPS);  // 递归调用，创建动画循环
  const delta = now - then;              // 计算时间差

  if (delta > interval) {                // 判断是否应该更新帧
    then = now - (delta % interval);     // 更新时间戳（关键步骤）
    this.updateFrame();                  // 执行帧更新
  }
};

requestAnimationFrame(animateWithFPS);   // 启动动画循环
```



#### Promise.allSettled